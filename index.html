<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Civil Engineering – Oblique Triangles (Sine & Cosine Rule)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    :root{
      --accent:#6a5cff;
      --accent2:#00c2ff;
      --ink:#0f172a;
      --muted:#55607a;
      --success:#2e7d32;
      --error:#e53935;
      --surface:#ffffff;
      --field-w:11rem;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial,sans-serif;
      margin:0;color:var(--ink);
      background:
        radial-gradient(1200px 600px at 10% -10%, #dfe8ff, transparent 60%),
        radial-gradient(1200px 600px at 110% 10%, #ccfbff, transparent 60%),
        linear-gradient(180deg,#f5f8ff 0%, #f0fbff 50%, #eef3ff 100%);
    }
    h1{
      margin:0.7rem 0 0.4rem;text-align:center;
      font-size:1.6rem;font-weight:900;
      background:linear-gradient(90deg,var(--accent),var(--accent2));
      -webkit-background-clip:text;background-clip:text;color:transparent;
      letter-spacing:.2px
    }
    p.lede{max-width:980px;margin:0.2rem auto 0.6rem;text-align:center;color:#1f2a44}

    .logo{position:absolute;top:10px;left:10px;width:110px;height:auto;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,.15)}

    /* Top bar */
    .topbar{
      max-width:980px;margin:0.15rem auto 0.65rem;display:flex;gap:0.6rem;
      justify-content:space-between;align-items:center;padding:0 0.6rem
    }
    .badge{
      background:#fff;border:1px solid rgba(106,92,255,.25);border-radius:14px;
      padding:0.5rem 0.7rem;font-weight:800;min-width:120px;text-align:center;
      box-shadow:0 3px 10px rgba(106,92,255,.08)
    }
    .badge small{display:block;font-weight:600;color:var(--muted);margin-top:2px;font-size:.82rem}
    .top-actions{display:flex;gap:0.45rem;align-items:center}
    .fsBtn{
      border:1px solid rgba(0,194,255,.5);background:linear-gradient(180deg,#ffffff,#f3fcff);
      border-radius:12px;padding:.55rem .8rem;font-weight:900;cursor:pointer;color:#0b3d4a;
      box-shadow:0 3px 10px rgba(0,194,255,.15)
    }
    .fsBtn:hover{background:#ecfbff}

    /* Card */
    .card{
      max-width:980px;margin:0.25rem auto;background:var(--surface);border-radius:16px;
      border:2px solid rgba(106,92,255,.35);
      box-shadow:0 12px 30px rgba(106,92,255,.12), 0 6px 14px rgba(0,0,0,.06);
      padding:0.95rem
    }
    .titleRow{display:flex;justify-content:space-between;align-items:flex-start;gap:1rem}
    .qTitle{font-size:1.15rem;font-weight:900;color:#2c3477;margin:0.1rem 0}
    .qMeta{color:var(--muted);font-size:.95rem}

    .statement{font-size:1.5rem;margin:0.55rem 0 0.7rem;line-height:1.35}
    .statement b{font-weight:900}

    details{border:1px solid rgba(106,92,255,.3);border-radius:12px;margin:0.5rem 0;background:#fbfcff}
    summary{cursor:pointer;font-weight:900;color:#2c3477;padding:0.6rem 0.8rem;list-style:none}
    summary::-webkit-details-marker{display:none}
    .hint{padding:0 0.9rem 0.85rem;font-size:1rem;color:#1f2a44}

    /* Inputs */
    .io{display:grid;gap:0.8rem;margin-top:0.5rem}
    .row{display:grid;grid-template-columns:1.2fr auto auto auto 1fr;align-items:center;gap:.6rem}
    .row label{font-weight:900;color:#1f2a44;font-size:1.05rem}
    .unit{
      background:linear-gradient(180deg,#eef4ff,#f7fbff);
      border:1px solid rgba(0,194,255,.35);
      color:#173a56;border-radius:10px;padding:0.35rem 0.6rem;font-weight:900;min-width:6.5rem;text-align:center
    }
    .num{
      width:var(--field-w);text-align:center;border:1px solid rgba(106,92,255,.45);
      border-radius:10px;font-size:1.02rem;padding:.48rem .4rem;background:linear-gradient(180deg,#ffffff,#f6f7ff);
      box-shadow:inset 0 1px 2px rgba(0,0,0,.06)
    }
    .num:focus{outline:none;border-color:var(--accent);box-shadow:0 0 0 3px rgba(106,92,255,.18)}

    /* Markers & feedback */
    .marker{font-size:1.45rem;font-weight:900;min-width:1.9rem;text-align:center}
    .ok{color:var(--success); animation:pop .25s ease-out}
    .no{color:var(--error)}
    @keyframes pop { 0%{transform:scale(0.85)} 100%{transform:scale(1)} }
    .feedback{font-size:0.95rem;color:#1f2a44}
    .feedback .ans{font-weight:900}

    /* Controls */
    .controls{display:flex;justify-content:center;gap:.6rem;margin-top:0.75rem;flex-wrap:wrap}
    button.primary{
      background:linear-gradient(90deg,var(--accent),var(--accent2));
      color:#fff;border:none;border-radius:12px;padding:.7rem 1.2rem;font-weight:900;cursor:pointer;
      box-shadow:0 8px 18px rgba(106,92,255,.25)
    }
    button.secondary{
      background:#111827;color:#fff;border:none;border-radius:12px;padding:.7rem 1.2rem;font-weight:900;cursor:pointer
    }
    button.ghost{
      background:linear-gradient(180deg,#ffffff,#f7f9ff);border:1px solid rgba(17,24,39,.25);
      border-radius:12px;padding:.6rem 1rem;font-weight:900;cursor:pointer;color:#111827
    }
    button:disabled{opacity:.6;cursor:not-allowed}
    #progress{font-weight:900;text-align:center;color:#111827;margin:0.15rem 0 0.6rem}

    /* Start modal */
    .modal{position:fixed;inset:0;background:rgba(15,23,42,.35);display:flex;align-items:center;justify-content:center;padding:1rem;z-index:999}
    .panel{
      background:linear-gradient(180deg,#ffffff,#f7f8ff);
      border-radius:16px;max-width:780px;width:100%;
      box-shadow:0 18px 40px rgba(17,24,39,.25);border:2px solid rgba(106,92,255,.35)
    }
    .panel header{padding:0.9rem 1rem;border-bottom:1px solid rgba(106,92,255,.25)}
    .panel header h2{margin:0;color:#2c3477}
    .panel .content{padding:1rem;display:grid;gap:0.9rem}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:0.8rem}
    .field{display:grid;gap:0.35rem}
    .field input[type=text], .field input[type=number], .field select{
      padding:0.55rem .6rem;border:1px solid rgba(106,92,255,.4);border-radius:10px;background:#fff
    }
    .choiceRow{display:flex;gap:.75rem;align-items:center;flex-wrap:wrap}
    .pill{border:1px solid rgba(106,92,255,.45);padding:.35rem .7rem;border-radius:999px;cursor:pointer;font-weight:900;background:#fff}
    .pill input{margin-right:.35rem}
    .panel footer{display:flex;justify-content:space-between;align-items:center;padding:0.85rem 1rem;border-top:1px solid rgba(106,92,255,.25)}
    .muted{color:var(--muted);font-size:.95rem}

    /* End screen */
    #endCard{max-width:820px;margin:1rem auto;padding:1rem;border-radius:14px;background:#fff;border:2px solid #2e7d32;display:none}
    #endCard h3{margin-top:0;color:#1e7a31}
    .wellDone{display:inline-block;background:#eaf7ec;border:1px solid #b9e2bf;color:#1e7a31;padding:.25rem .5rem;border-radius:8px;font-weight:900}

    /* Figures (SVG) – larger */
    .fig{max-width:980px;width:100%;height:auto;display:block;margin:.5rem auto;border-radius:12px;box-shadow:0 8px 20px rgba(0,0,0,.08);background:#fff}
  </style>
</head>
<body>
  <img src="https://lirp.cdn-website.com/b085c470/dms3rep/multi/opt/Bucks%2BCollege%2BGroup-e5af1b68-1920w.jpg"
       alt="Bucks College Group logo" class="logo">

  <h1>Oblique Triangles — Sine Rule &amp; Cosine Rule (Civil Engineering)</h1>
  <p class="lede">Non‑right geometry for stays, set‑out and offsets. <strong>Triangles are not right‑angled.</strong> Symbols show angle positions only. All answers to <strong>2 dp</strong>.</p>

  <div class="topbar">
    <div style="display:flex;gap:0.6rem;align-items:center">
      <div class="badge" id="who"><span id="whoName">Student</span><small>Participant</small></div>
      <div class="badge" id="mode"><span id="modeTxt">Timed</span><small>Mode</small></div>
      <div class="badge" id="timer"><span id="timeTxt">—</span><small>Timer</small></div>
      <div class="badge" id="scoreTop"><span id="scoreTopVal">0 / 0</span><small>Score</small></div>
    </div>
    <div class="top-actions">
      <button class="fsBtn" id="fsBtn" title="Toggle full screen">⛶ Full screen</button>
    </div>
  </div>

  <!-- Quick refresher only -->
  <div class="card" id="globalHint">
    <details open>
      <summary>Quick refresher (formulas)</summary>
      <div class="hint">
        <ul>
          <li><strong>Sine Rule:</strong> \(\displaystyle \frac{a}{\sin\alpha}=\frac{b}{\sin\beta}=\frac{c}{\sin\gamma}\).</li>
          <li><strong>Cosine Rule:</strong> \(\displaystyle
            a^2=b^2+c^2-2bc\cos\alpha,\quad
            b^2=c^2+a^2-2ca\cos\beta,\quad
            c^2=a^2+b^2-2ab\cos\gamma.\)</li>
          <li><strong>Rearrange as needed.</strong> Round final answers to <strong>2 dp</strong>.</li>
        </ul>
      </div>
    </details>
  </div>

  <!-- Question card -->
  <div class="card" id="qCard" style="display:none">
    <div class="titleRow">
      <div>
        <div class="qTitle" id="qTitle">Question</div>
        <div class="qMeta">Use the to‑scale diagram. Enter each requested value to <strong>2 dp</strong>, then click <strong>Check</strong>.</div>
      </div>
      <div class="qMeta" id="progress">Question 1</div>
    </div>

    <div class="statement" id="statement"></div>

    <details id="whyBox">
      <summary>Why this matters (click to expand)</summary>
      <div class="hint" id="whyHtml"></div>
    </details>

    <div class="io" id="io"></div>

    <div class="controls">
      <button class="primary" id="checkBtn">Check</button>
      <button class="ghost" id="nextBtn" disabled>Next</button>
      <button class="secondary" id="newBtn">New questions</button>
    </div>
  </div>

  <!-- End summary -->
  <div id="endCard">
    <h3>Summary</h3>
    <p class="wellDone" id="endMsg"></p>
    <ul>
      <li><strong>Name:</strong> <span id="sumName"></span></li>
      <li><strong>Mode:</strong> <span id="sumMode"></span></li>
      <li><strong>Score:</strong> <span id="sumScore"></span></li>
      <li><strong>Time used:</strong> <span id="sumTime"></span></li>
    </ul>
    <div style="display:flex;gap:.6rem;justify-content:center;margin-top:.4rem">
      <button class="secondary" id="restartBtn">Restart</button>
    </div>
  </div>

  <!-- Start menu modal -->
  <div class="modal" id="startModal">
    <div class="panel">
      <header><h2>Start Worksheet</h2></header>
      <div class="content">
        <div class="field">
          <label for="nameInput"><strong>Your name</strong></label>
          <input id="nameInput" type="text" placeholder="Type your name…" autocomplete="name">
        </div>

        <div class="field">
          <label><strong>Mode</strong></label>
          <div class="choiceRow">
            <label class="pill"><input type="radio" name="mode" value="timed" checked>Timed</label>
            <label class="pill"><input type="radio" name="mode" value="target">Target</label>
          </div>
        </div>

        <div class="grid2">
          <div class="field" id="timedField" style="display:block">
            <label><strong>Time limit</strong></label>
            <div class="choiceRow">
              <label class="pill"><input type="radio" name="tlimit" value="600">10 minutes</label>
              <label class="pill"><input type="radio" name="tlimit" value="1200" checked>20 minutes</label>
              <label class="pill"><input type="radio" name="tlimit" value="1800">30 minutes</label>
              <label class="pill"><input type="radio" name="tlimit" value="0">Unlimited</label>
            </div>
          </div>

          <div class="field" id="targetField" style="display:none">
            <label for="targetInput"><strong>Target (correct answers to finish)</strong></label>
            <input id="targetInput" type="number" min="1" max="1000" step="1" value="10">
          </div>
        </div>

        <div class="grid2">
          <div class="field">
            <label for="qtyInput"><strong>Total questions (per set)</strong></label>
            <select id="qtyInput">
              <option value="8">8</option>
              <option value="10" selected>10</option>
              <option value="12">12</option>
              <option value="15">15</option>
            </select>
          </div>
          <div class="field">
            <div class="muted">Diagrams are to scale. Symbols show angle positions only (values are in the text). Answers to <strong>2 dp</strong>.</div>
          </div>
        </div>
      </div>
      <footer>
        <span class="muted">You can generate a fresh random set any time.</span>
        <div>
          <button class="primary" id="startBtn">Start worksheet</button>
        </div>
      </footer>
    </div>
  </div>

  <div id="errBanner" style="display:none;position:fixed;bottom:10px;left:50%;transform:translateX(-50%);
    background:#fee;border:2px solid #e53935;color:#7f1d1d;padding:.5rem .8rem;border-radius:10px;font-weight:800;z-index:2000"></div>
  <noscript><div style="margin:1rem auto;max-width:980px;color:#b91c1c;background:#fee;border:2px solid #e11d48;padding:.6rem;border-radius:12px;font-weight:800">This worksheet needs JavaScript enabled.</div></noscript>

<script>
'use strict';

window.addEventListener('error', (e) => {
  const b = document.getElementById('errBanner');
  b.textContent = 'Error: ' + (e.message || 'Unknown script error');
  b.style.display = 'block';
});

window.addEventListener('DOMContentLoaded', () => {

  /* ========= Helpers ========= */
  const rnd=(m,M)=>Math.floor(Math.random()*(M-m+1))+m;
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const rndf=(min,max,dp=2)=>+((Math.random()*(max-min)+min).toFixed(dp));
  const round2=x=>Math.round((+x + Number.EPSILON)*100)/100;
  const to2=x=>isFinite(x)?round2(x).toFixed(2):'—';
  const parseNum = (input) => {
    const raw = (typeof input === 'string' ? input : (input?.value ?? '')).toString().trim().replace(',','.');
    const x = parseFloat(raw);
    return isFinite(x)?x:NaN;
  };
  const deg = r=>r*180/Math.PI;
  const rad = d=>d*Math.PI/180;
  const eq2dp=(a,b)=>isFinite(a)&&isFinite(b)&&round2(a)===round2(b);
  const secsToMMSS=s=>{const m=Math.floor(s/60), ss=String(s%60).padStart(2,'0'); return `${m}:${ss}`;};
  const unit = (u) => ({ m:'m', deg:'°' }[u]||u);
  const lines = arr => arr.join('<br>');

  /* ========= SVG & Robust Layout ========= */
  function figWrap(viewW, viewH, inner){
    return `<svg class="fig" viewBox="0 0 ${viewW} ${viewH}" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="diagram">
      <defs>
        <style>
          .tri{stroke:#1f2a44;stroke-width:2}
          .tri.c1{fill:rgba(106,92,255,.24)}
          .tri.c2{fill:rgba(0,194,255,.22)}
          .tri.c3{fill:rgba(255,159,67,.22)}
          .tri.c4{fill:rgba(34,197,94,.22)}
          .tri.c5{fill:rgba(236,72,153,.22)}
          .tri.c6{fill:rgba(14,165,233,.22)}
          .tri.c7{fill:rgba(250,204,21,.22)}

          .aux{stroke:#334155;stroke-dasharray:6 4;stroke-width:2;fill:none}
          .tick{stroke:#1f2a44;stroke-width:2}
          .dim{
            font:700 21px/1 Inter, system-ui;
            fill:#0f172a;
            paint-order:stroke fill; stroke:#ffffff; stroke-width:3px;
          }
          .ang{
            font:800 26px/1.1 Inter, system-ui;
            fill:#1e2a66;
            paint-order:stroke fill; stroke:#ffffff; stroke-width:3.5px;
          }
          .label{font:800 16px/1 Inter, system-ui; fill:#2c3477; paint-order:stroke fill; stroke:#fff; stroke-width:1.5px;}
        </style>
      </defs>
      ${inner}
    </svg>`;
  }

  // Compute raw coords (A=0,0; B=c,0; C=(cx,cy))
  function coreCoords(a,b,c){
    const cx = (b*b + c*c - a*a)/(2*c);
    const h2 = Math.max(1e-9, b*b - cx*cx);
    const cy = Math.sqrt(h2);
    return {cx, cy};
  }

  function layoutOblique(a,b,c, w=980, h=720, margins={left:160,right:160,top:120,baseBottom:220}){
    const {cx, cy} = coreCoords(a,b,c);
    const minX = Math.min(0, c, cx);
    const maxX = Math.max(0, c, cx);
    const rawWidth = maxX - minX;

    const availW = Math.max(240, w - margins.left - margins.right);
    const availH = Math.max(180, h - margins.top - margins.baseBottom);

    const s = Math.min(availW/rawWidth, availH/cy);

    const xShift = margins.left + (availW - rawWidth*s)/2 - minX*s;
    const yTop = margins.top + (availH - cy*s)/2;
    const yBase = yTop + cy*s;

    const A = [xShift + 0,     yBase];
    const B = [xShift + c*s,   yBase];
    const C = [xShift + cx*s,  yTop];

    return { A, B, C, w, h };
  }

  const insetFor = lenPx => clamp(lenPx*0.12, 12, 30);

  function dimBase(A,B,label,w,h){
    const [x0,y0]=A, [x1,y1]=B;
    const L = Math.hypot(x1-x0,y1-y0);
    const inset=insetFor(L), off=68, ext=34, dimY=y0+off;
    return `
      <line x1="${x0}" y1="${y0}" x2="${x0}" y2="${dimY+ext}" class="aux"/>
      <line x1="${x1}" y1="${y1}" x2="${x1}" y2="${dimY+ext}" class="aux"/>
      <line x1="${x0+inset}" y1="${dimY}" x2="${x1-inset}" y2="${dimY}" class="aux"/>
      <line x1="${x0+inset}" y1="${dimY-7}" x2="${x0+inset}" y2="${dimY+7}" class="tick"/>
      <line x1="${x1-inset}" y1="${dimY-7}" x2="${x1-inset}" y2="${dimY+7}" class="tick"/>
      ${label?`<text x="${(x0+x1)/2}" y="${dimY+22}" text-anchor="middle" dominant-baseline="hanging" class="dim">${label}</text>`:''}
    `;
  }

  function dimAlongEdge(P,Q,G,label,w,h){
    if(!label) return '';
    const margin=12;
    const [px,py]=P, [qx,qy]=Q;
    const dx=qx-px, dy=qy-py;
    const L = Math.hypot(dx,dy)||1; const tx=dx/L, ty=dy/L;

    let nx=-ty, ny=tx;
    const mx=(px+qx)/2, my=(py+qy)/2;
    if(nx*(mx-G[0]) + ny*(my-G[1]) < 0){ nx=-nx; ny=-ny; }

    const inset=insetFor(L), off=44, ext=32;

    function pack(nx,ny){
      const P1x=px + nx*off + tx*inset, P1y=py + ny*off + ty*inset;
      const P2x=qx + nx*off - tx*inset, P2y=qy + ny*off - ty*inset;
      const EA1x1=px + nx*2, EA1y1=py + ny*2;
      const EA1x2=px + nx*(off+ext), EA1y2=py + ny*(off+ext);
      const EA2x1=qx + nx*2, EA2y1=qy + ny*2;
      const EA2x2=qx + nx*(off+ext), EA2y2=qy + ny*(off+ext);
      const midx=(P1x+P2x)/2, midy=(P1y+P2y)/2;
      let angle = Math.atan2(P2y-P1y, P2x-P1x)*180/Math.PI;
      if(angle>90) angle-=180;
      if(angle<-90) angle+=180;
      const labOff=22;
      const lx = midx + nx*labOff, ly = midy + ny*labOff;
      return {P1x,P1y,P2x,P2y,EA1x1,EA1y1,EA1x2,EA1y2,EA2x1,EA2y1,EA2x2,EA2y2,lx,ly,angle};
    }

    let d=pack(nx,ny);
    const inside = (d)=>(
      d.lx>margin && d.ly>margin && d.lx<w-margin && d.ly<h-margin &&
      d.P1x>margin && d.P1y>margin && d.P2x>margin && d.P2y>margin &&
      d.P1x<w-margin && d.P1y<h-margin && d.P2x<w-margin && d.P2y<h-margin &&
      d.EA1x2>margin && d.EA1y2>margin && d.EA2x2>margin && d.EA2y2>margin &&
      d.EA1x2<w-margin && d.EA1y2<h-margin && d.EA2x2<w-margin && d.EA2y2<h-margin
    );
    if(!inside(d)){ nx=-nx; ny=-ny; d=pack(nx,ny); }

    return `
      <line x1="${d.EA1x1}" y1="${d.EA1y1}" x2="${d.EA1x2}" y2="${d.EA1y2}" class="aux"/>
      <line x1="${d.EA2x1}" y1="${d.EA2y1}" x2="${d.EA2x2}" y2="${d.EA2y2}" class="aux"/>
      <line x1="${d.P1x}" y1="${d.P1y}" x2="${d.P2x}" y2="${d.P2y}" class="aux"/>
      <text x="${d.lx}" y="${d.ly}" text-anchor="middle" dominant-baseline="middle"
        class="dim" transform="rotate(${d.angle} ${d.lx} ${d.ly})">${label}</text>
    `;
  }

  function angleSymbol(V, V1, V2, sym){
    const [vx,vy]=V, [v1x,v1y]=V1, [v2x,v2y]=V2;
    const u1x=v1x-vx, u1y=v1y-vy, u2x=v2x-vx, u2y=v2y-vy;
    const L1=Math.hypot(u1x,u1y)||1, L2=Math.hypot(u2x,u2y)||1;
    let bx=u1x/L1 + u2x/L2, by=u1y/L1 + u2y/L2;
    const bL=Math.hypot(bx,by)||1; bx/=bL; by/=bL;
    const d=28;
    const lx = vx + bx*d, ly = vy + by*d;
    return `<text x="${lx}" y="${ly}" class="ang">${sym}</text>`;
  }
  function pickTriClass(){ return 'c' + rnd(1,7); }

  function svgOblique(a,b,c, labels, caption='Oblique triangle', triClass='c1'){
    const w=980, h=720;
    const {A, B, C} = layoutOblique(a,b,c,w,h,{left:160,right:160,top:120,baseBottom:230});
    const G=[(A[0]+B[0]+C[0])/3, (A[1]+B[1]+C[1])/3];

    const inner=`
      <text x="${w/2}" y="30" text-anchor="middle" class="label">${caption}</text>
      <polygon points="${A[0]},${A[1]} ${B[0]},${B[1]} ${C[0]},${C[1]}" class="tri ${triClass}"/>

      ${angleSymbol(A, B, C, 'α')}
      ${angleSymbol(B, A, C, 'β')}
      ${angleSymbol(C, A, B, 'γ')}

      ${dimBase(A,B, labels.c, w, h)}
      ${dimAlongEdge(A,C,G, labels.b, w, h)}
      ${dimAlongEdge(B,C,G, labels.a, w, h)}
    `;
    return figWrap(w,h,inner);
  }

  /* ========= IO builder ========= */
  function buildIORows(parts){
    const io = document.getElementById('io');
    io.innerHTML = '';
    parts.forEach((p,i) => {
      const row = document.createElement('div');
      row.className = 'row';
      row.innerHTML = `
        <label>${p.prompt}</label>
        <input class="num" id="ans-${i}" type="text" inputmode="decimal" autocomplete="off" placeholder="e.g. 12.34">
        <span class="unit">${unit(p.unit)}</span>
        <span class="marker" id="mark-${i}"></span>
        <span class="feedback" id="fb-${i}"></span>
      `;
      io.appendChild(row);
    });
    io.querySelectorAll('input.num').forEach(inp=>{
      inp.addEventListener('blur', ()=>{
        const x = parseNum(inp.value);
        if(isFinite(x)) inp.value = to2(x);
      });
    });
  }

  /* ========= Question generators ========= */
  function clampTrig(x){ return clamp(x,-1,1); }
  function pickSSA_a_unique(b, betaDeg){
    const s = Math.sin(rad(betaDeg));
    if(Math.random()<0.5){
      return rndf(b*1.05, b*1.6, 2);
    }else{
      const upper = Math.max(0.8, b*s*0.95);
      return rndf(0.5, upper, 2);
    }
  }

  function qBridgeTie_SAS(){
    const b = rndf(8, 25, 2);
    const c = rndf(10, 28, 2);
    const alpha = rndf(30, 120, 2);
    const a = Math.sqrt(b*b + c*c - 2*b*c*Math.cos(rad(alpha)));
    const beta = deg(Math.asin(clampTrig(b*Math.sin(rad(alpha))/a)));
    return {
      title:'Bridge tie geometry — find a and β from b, c and α',
      statementHTML: lines([
        `On a bridge approach a steel tie links two anchor points forming triangle <b>ABC</b>.`,
        `The base <b>AB</b> is side <b>c = ${c.toFixed(2)} m</b>.`,
        `The side <b>AC</b> is side <b>b = ${b.toFixed(2)} m</b>.`,
        `The included angle at <b>A</b> is <b>α = ${alpha.toFixed(2)}°</b>.`,
        `Find the remaining side <b>a</b> and the angle <b>β</b> at <b>B</b>.`
      ]) + svgOblique(a, b, c, { a:'a = ?', b:`b = ${b.toFixed(2)} m`, c:`c = ${c.toFixed(2)} m` }, 'Bridge tie (to scale)', pickTriClass()),
      whyHTML:`<ul>
        <li>Checks whether tie lengths on the fixing schedule match setting‑out tolerances.</li>
        <li>Ensures clevis positions keep ties clear of parapets and services.</li>
        <li>Confirms temporary clearances during installation.</li>
      </ul>`,
      parts:[
        { prompt:'Side a', unit:'m', val: a },
        { prompt:'Angle β', unit:'deg', val: beta }
      ]
    };
  }

  function qSurvey_SSA(){
    const b = rndf(12, 32, 2);
    const beta = rndf(25, 130, 2);
    const a = pickSSA_a_unique(b, beta);
    const alpha = deg(Math.asin(clampTrig(a*Math.sin(rad(beta))/b)));
    const gamma = 180 - alpha - beta;
    const c = Math.sqrt(a*a + b*b - 2*a*b*Math.cos(rad(gamma)));
    return {
      title:'Topographic resection — find γ and c from a, b and β',
      statementHTML: lines([
        `A control point is positioned using triangle <b>ABC</b> from two known marks.`,
        `The side <b>AC</b> is <b>b = ${b.toFixed(2)} m</b> and the side <b>BC</b> is <b>a = ${a.toFixed(2)} m</b>.`,
        `The observed angle at <b>B</b> is <b>β = ${beta.toFixed(2)}°</b>.`,
        `Find the angle at <b>C</b>, <b>γ</b>, and the base <b>c</b>.`
      ]) + svgOblique(a, b, c, { a:`a = ${a.toFixed(2)} m`, b:`b = ${b.toFixed(2)} m`, c:'c = ?' }, 'Resection triangle (to scale)', pickTriClass()),
      whyHTML:`<ul>
        <li>Supports control where direct measurement is obstructed by hoarding or traffic.</li>
        <li>Allows closure checks between total station observations and tape readings.</li>
        <li>Builds confidence in coordinates before works proceed.</li>
      </ul>`,
      parts:[
        { prompt:'Angle γ', unit:'deg', val: gamma },
        { prompt:'Side c', unit:'m', val: c }
      ]
    };
  }

  function qRoofBracing_SSS(){
    const a = rndf(6, 22, 2);
    const b = rndf(6, 22, 2);
    const c = rndf(Math.max(5, Math.abs(a-b)+1), a+b-1, 2);
    const alpha = deg(Math.acos(clampTrig((b*b + c*c - a*a)/(2*b*c))));
    const beta  = deg(Math.acos(clampTrig((c*c + a*a - b*b)/(2*c*a))));
    return {
      title:'Roof bracing panel — find α and β from a, b and c',
      statementHTML: lines([
        `A roof bracing panel forms triangle <b>ABC</b> between nodes on a truss chord.`,
        `The measured panel sides are <b>a = ${a.toFixed(2)} m</b>, <b>b = ${b.toFixed(2)} m</b>, and <b>c = ${c.toFixed(2)} m</b>.`,
        `Find the angles <b>α</b> at <b>A</b> and <b>β</b> at <b>B</b>.`
      ]) + svgOblique(a, b, c, { a:`a = ${a.toFixed(2)} m`, b:`b = ${b.toFixed(2)} m`, c:`c = ${c.toFixed(2)} m` }, 'Bracing triangle (to scale)', pickTriClass()),
      whyHTML:`<ul>
        <li>Determines gusset plate orientation and bolt edge distances.</li>
        <li>Confirms brace geometry against fabrication drawings.</li>
        <li>Avoids clashes with purlins and containment routes.</li>
      </ul>`,
      parts:[
        { prompt:'Angle α', unit:'deg', val: alpha },
        { prompt:'Angle β', unit:'deg', val: beta }
      ]
    };
  }

  function qWallAnchors_SAS(){
    const c = rndf(10, 28, 2);
    const a = rndf(8, 25, 2);
    const beta = rndf(35, 130, 2);
    const b = Math.sqrt(c*c + a*a - 2*c*a*Math.cos(rad(beta)));
    const gamma = deg(Math.asin(clampTrig(c*Math.sin(rad(beta))/b)));
    return {
      title:'Retaining wall anchors — find b and γ from c, a and β',
      statementHTML: lines([
        `Two soil anchors and the wall toe define triangle <b>ABC</b> for a tie arrangement.`,
        `The base <b>AB</b> is <b>c = ${c.toFixed(2)} m</b> and the side <b>BC</b> is <b>a = ${a.toFixed(2)} m</b>.`,
        `The included angle at <b>B</b> is <b>β = ${beta.toFixed(2)}°</b>.`,
        `Find the remaining side <b>b</b> and the angle at <b>C</b>, <b>γ</b>.`
      ]) + svgOblique(a, b, c, { a:`a = ${a.toFixed(2)} m`, b:'b = ?', c:`c = ${c.toFixed(2)} m` }, 'Anchor fan (to scale)', pickTriClass()),
      whyHTML:`<ul>
        <li>Sets anchor fan spread to avoid services and piles.</li>
        <li>Helps select plate sizes and turnbuckle ranges.</li>
        <li>Ensures movement monitors have clearance.</li>
      </ul>`,
      parts:[
        { prompt:'Side b', unit:'m', val: b },
        { prompt:'Angle γ', unit:'deg', val: gamma }
      ]
    };
  }

  function qCraneJib_SAS(){
    const a = rndf(10, 36, 2);
    const b = rndf(14, 40, 2);
    const gamma = rndf(25, 130, 2);
    const c = Math.sqrt(a*a + b*b - 2*a*b*Math.cos(rad(gamma)));
    const beta = deg(Math.asin(clampTrig(b*Math.sin(rad(gamma))/c)));
    return {
      title:'Crane jib set‑out — find c and β from a, b and γ',
      statementHTML: lines([
        `A jib, the hook path and a façade corner mark triangle <b>ABC</b>.`,
        `The sides are <b>a = ${a.toFixed(2)} m</b> and <b>b = ${b.toFixed(2)} m</b> with included angle <b>γ = ${gamma.toFixed(2)}°</b> at <b>C</b>.`,
        `Find the base <b>c</b> and the angle at <b>B</b>, <b>β</b>.`
      ]) + svgOblique(a, b, c, { a:`a = ${a.toFixed(2)} m`, b:`b = ${b.toFixed(2)} m`, c:'c = ?' }, 'Crane reach triangle (to scale)', pickTriClass()),
      whyHTML:`<ul>
        <li>Checks reach without breaching oversail restrictions.</li>
        <li>Positions exclusion zones and lifting points on slabs.</li>
        <li>Supports selection of feasible jib options.</li>
      </ul>`,
      parts:[
        { prompt:'Side c', unit:'m', val: c },
        { prompt:'Angle β', unit:'deg', val: beta }
      ]
    };
  }

  function qSheetPile_SSA(){
    const b = rndf(9, 22, 2);
    const beta = rndf(30, 130, 2);
    const a = pickSSA_a_unique(b, beta);
    const alpha = deg(Math.asin(clampTrig(a*Math.sin(rad(beta))/b)));
    const gamma = 180 - alpha - beta;
    const c = Math.sqrt(a*a + b*b - 2*a*b*Math.cos(rad(gamma)));
    return {
      title:'Sheet pile tie‑back — find α and c from β, b and a',
      statementHTML: lines([
        `A tie‑rod from a waling to an anchor forms triangle <b>ABC</b> with the excavation toe.`,
        `The measured distances are <b>b = ${b.toFixed(2)} m</b> and <b>a = ${a.toFixed(2)} m</b>.`,
        `The observed angle at <b>B</b> is <b>β = ${beta.toFixed(2)}°</b>.`,
        `Find the angle at <b>A</b>, <b>α</b>, and the base <b>c</b>.`
      ]) + svgOblique(a, b, c, { a:`a = ${a.toFixed(2)} m`, b:`b = ${b.toFixed(2)} m`, c:'c = ?' }, 'Tie‑back triangle (to scale)', pickTriClass()),
      whyHTML:`<ul>
        <li>Confirms tie lengths and pin locations match temporary works design.</li>
        <li>Reduces time near open excavations by checking geometry in advance.</li>
        <li>Helps avoid utilities behind the wall line.</li>
      </ul>`,
      parts:[
        { prompt:'Angle α', unit:'deg', val: alpha },
        { prompt:'Side c', unit:'m', val: c }
      ]
    };
  }

  function qRiverStrut_SSS(){
    const a = rndf(12, 30, 2);
    const b = rndf(10, 28, 2);
    const c = rndf(Math.max(8, Math.abs(a-b)+1), a+b-1, 2);
    const beta = deg(Math.acos(clampTrig((c*c + a*a - b*b)/(2*c*a))));
    const alpha = deg(Math.acos(clampTrig((b*b + c*c - a*a)/(2*b*c))));
    const gamma = 180 - alpha - beta;
    return {
      title:'River crossing strut — find β and γ from a, b and c',
      statementHTML: lines([
        `Temporary struts form triangle <b>ABC</b> across a cofferdam cell.`,
        `The measured side lengths are <b>a = ${a.toFixed(2)} m</b>, <b>b = ${b.toFixed(2)} m</b>, and <b>c = ${c.toFixed(2)} m</b>.`,
        `Find the angles <b>β</b> and <b>γ</b>.`
      ]) + svgOblique(a, b, c, { a:`a = ${a.toFixed(2)} m`, b:`b = ${b.toFixed(2)} m`, c:`c = ${c.toFixed(2)} m` }, 'Cofferdam struts (to scale)', pickTriClass()),
      whyHTML:`<ul>
        <li>Verifies strut bearing plates sit square to waling frames.</li>
        <li>Improves estimation of jack stroke during pre‑load.</li>
        <li>Supports clash checks with pumps and risers in the cofferdam.</li>
      </ul>`,
      parts:[
        { prompt:'Angle β', unit:'deg', val: beta },
        { prompt:'Angle γ', unit:'deg', val: gamma }
      ]
    };
  }

  function qPortalBrace_SAS(){
    const b = rndf(8, 22, 2);
    const c = rndf(10, 24, 2);
    const alpha = rndf(35, 120, 2);
    const a = Math.sqrt(b*b + c*c - 2*b*c*Math.cos(rad(alpha)));
    const gamma = deg(Math.asin(clampTrig(c*Math.sin(rad(alpha))/a)));
    return {
      title:'Portal frame fly‑brace — find a and γ from α, b and c',
      statementHTML: lines([
        `A fly‑brace from a column to a rafter forms triangle <b>ABC</b>.`,
        `The sides about the included angle are <b>b = ${b.toFixed(2)} m</b> and <b>c = ${c.toFixed(2)} m</b>.`,
        `The included angle at <b>A</b> is <b>α = ${alpha.toFixed(2)}°</b>.`,
        `Find the brace length <b>a</b> and the angle at <b>C</b>, <b>γ</b>.`
      ]) + svgOblique(a, b, c, { a:'a = ?', b:`b = ${b.toFixed(2)} m`, c:`c = ${c.toFixed(2)} m` }, 'Fly‑brace triangle (to scale)', pickTriClass()),
      whyHTML:`<ul>
        <li>Confirms brace length against stock sizes before procurement.</li>
        <li>Helps position hole centres in connection plates.</li>
        <li>Ensures clearances to purlin lines and bracing nodes.</li>
      </ul>`,
      parts:[
        { prompt:'Side a', unit:'m', val: a },
        { prompt:'Angle γ', unit:'deg', val: gamma }
      ]
    };
  }

  function qRoadOffset_SSA(){
    const c = rndf(14, 32, 2);
    const gamma = rndf(35, 130, 2);
    const a = pickSSA_a_unique(c, gamma);
    const alpha = deg(Math.asin(clampTrig(a*Math.sin(rad(gamma))/c)));
    const beta = 180 - alpha - gamma;
    const b = Math.sqrt(a*a + c*c - 2*a*c*Math.cos(rad(beta)));
    return {
      title:'Road alignment offset — find β and b from γ, c and a',
      statementHTML: lines([
        `Two sight lines and an offset peg form triangle <b>ABC</b> for setting out a tie.`,
        `The base <b>c = ${c.toFixed(2)} m</b> subtends the known angle at <b>C</b> of <b>γ = ${gamma.toFixed(2)}°</b>.`,
        `The side <b>a = ${a.toFixed(2)} m</b> is measured to the offset peg.`,
        `Find the angle at <b>B</b>, <b>β</b>, and the side <b>b</b>.`
      ]) + svgOblique(a, b, c, { a:`a = ${a.toFixed(2)} m`, b:'b = ?', c:`c = ${c.toFixed(2)} m` }, 'Alignment tie (to scale)', pickTriClass()),
      whyHTML:`<ul>
        <li>Speeds up chainage checks where GPS is screened by structures.</li>
        <li>Verifies peg positions before paving.</li>
        <li>Reduces re‑work by validating tie geometry ahead of pour.</li>
      </ul>`,
      parts:[
        { prompt:'Angle β', unit:'deg', val: beta },
        { prompt:'Side b', unit:'m', val: b }
      ]
    };
  }

  function qFacade_SAS(){
    const a = rndf(6, 20, 2);
    const c = rndf(8, 22, 2);
    const beta = rndf(30, 120, 2);
    const b = Math.sqrt(a*a + c*c - 2*a*c*Math.cos(rad(beta)));
    const alpha = deg(Math.asin(clampTrig(a*Math.sin(rad(beta))/b)));
    return {
      title:'Façade restraint — find b and α from β, a and c',
      statementHTML: lines([
        `Inclined restraints from slab to façade corner form triangle <b>ABC</b>.`,
        `The sides about the included angle at <b>B</b> are <b>a = ${a.toFixed(2)} m</b> and <b>c = ${c.toFixed(2)} m</b>.`,
        `The included angle is <b>β = ${beta.toFixed(2)}°</b>.`,
        `Find the remaining side <b>b</b> and the angle at <b>A</b>, <b>α</b>.`
      ]) + svgOblique(a, b, c, { a:`a = ${a.toFixed(2)} m`, b:'b = ?', c:`c = ${c.toFixed(2)} m` }, 'Façade restraint (to scale)', pickTriClass()),
      whyHTML:`<ul>
        <li>Ensures restraint bars clear façade panels and brackets.</li>
        <li>Helps order correct bar lengths and couplers.</li>
        <li>Improves coordination with temporary edge protection fixings.</li>
      </ul>`,
      parts:[
        { prompt:'Side b', unit:'m', val: b },
        { prompt:'Angle α', unit:'deg', val: alpha }
      ]
    };
  }

  /* ========= Pool & engine ========= */
  const GENERATORS = [
    qBridgeTie_SAS,
    qSurvey_SSA,
    qRoofBracing_SSS,
    qWallAnchors_SAS,
    qCraneJib_SAS,
    qSheetPile_SSA,
    qRiverStrut_SSS,
    qPortalBrace_SAS,
    qRoadOffset_SSA,
    qFacade_SAS
  ];

  let QUESTIONS=[], BATCH=10, idx=0, score=0;
  let nameStr='Student', mode='timed', timeLeft=0, timerId=null, target=0, correctSoFar=0, unlimited=false;
  let currentQ=null;

  const el = id=>document.getElementById(id);
  const $qCard=el('qCard');
  const $endCard=el('endCard');
  const $qTitle=el('qTitle'), $statement=el('statement'), $whyHtml=el('whyHtml');
  const $scoreTopVal=el('scoreTopVal'), $modeTxt=el('modeTxt'), $timeTxt=el('timeTxt');

  function buildSet(n){
    const gens=[...GENERATORS], qs=[];
    for(let i=0;i<n;i++){
      const g = gens.length ? gens.splice(Math.floor(Math.random()*gens.length),1)[0] : GENERATORS[Math.floor(Math.random()*GENERATORS.length)];
      const q = g();
      qs.push(q);
    }
    return qs;
  }

  function updateTop(){
    el('whoName').textContent = nameStr || 'Student';
    $modeTxt.textContent = mode==='timed' ? 'Timed' : 'Target';
    $scoreTopVal.textContent = `${score} / ${idx}`;
    $timeTxt.textContent = (mode==='timed' && !unlimited) ? secsToMMSS(timeLeft) : '—';
  }

  function startTimer(){
    if(mode!=='timed' || unlimited) return;
    clearInterval(timerId);
    // show starting value immediately
    $timeTxt.textContent = secsToMMSS(timeLeft);
    timerId = setInterval(()=>{
      if(timeLeft <= 1){
        timeLeft = 0;
        $timeTxt.textContent = secsToMMSS(timeLeft);
        clearInterval(timerId);
        finish('Time’s up!');
      }else{
        timeLeft -= 1;
        $timeTxt.textContent = secsToMMSS(timeLeft);
      }
    },1000);
  }

  function startWorksheet(){
    BATCH = parseInt(document.getElementById('qtyInput').value,10);
    QUESTIONS = buildSet(BATCH);
    idx=0; score=0; correctSoFar=0;
    $endCard.style.display='none';
    $qCard.style.display='block';
    renderQ();
    updateTop();
    if(window.MathJax && window.MathJax.typeset){ MathJax.typeset(); }
    startTimer(); // will no‑op if not timed or unlimited
  }

  function finish(message='Well done!'){
    clearInterval(timerId);
    $qCard.style.display='none';
    $endCard.style.display='block';
    el('endMsg').textContent = message;
    el('sumName').textContent = nameStr || 'Student';
    el('sumMode').textContent = ($modeTxt.textContent);
    el('sumScore').textContent = `${score} / ${idx}`;
    // compute used time only if timed & not unlimited
    const tSel = document.querySelector('input[name="tlimit"]:checked')?.value||'0';
    const setTime = (mode==='timed' && !unlimited) ? parseInt(tSel,10) : 0;
    const usedSecs = (mode==='timed' && !unlimited) ? (setTime - timeLeft) : 0;
    el('sumTime').textContent = (mode==='timed' && !unlimited) ? secsToMMSS(Math.max(0,usedSecs)) : '—';
  }

  function progressText(){
    return (mode==='timed') ? `Question ${idx+1}` : `Question ${idx+1} · Target ${correctSoFar}/${target}`;
  }

  function buildIORows(parts){
    const io = document.getElementById('io');
    io.innerHTML = '';
    parts.forEach((p,i) => {
      const row = document.createElement('div');
      row.className = 'row';
      row.innerHTML = `
        <label>${p.prompt}</label>
        <input class="num" id="ans-${i}" type="text" inputmode="decimal" autocomplete="off" placeholder="e.g. 12.34">
        <span class="unit">${unit(p.unit)}</span>
        <span class="marker" id="mark-${i}"></span>
        <span class="feedback" id="fb-${i}"></span>
      `;
      io.appendChild(row);
    });
    io.querySelectorAll('input.num').forEach(inp=>{
      inp.addEventListener('blur', ()=>{
        const x = parseNum(inp.value);
        if(isFinite(x)) inp.value = to2(x);
      });
    });
  }

  function renderQ(){
    const local = idx % QUESTIONS.length;
    currentQ = QUESTIONS[local];
    document.getElementById('progress').textContent = progressText();
    $qTitle.textContent = currentQ.title;
    $statement.innerHTML = currentQ.statementHTML;
    $whyHtml.innerHTML = currentQ.whyHTML || '';
    buildIORows(currentQ.parts);
    document.getElementById('nextBtn').disabled = true;
    $scoreTopVal.textContent = `${score} / ${idx}`;
    if(window.MathJax && window.MathJax.typeset){ MathJax.typeset(); }
  }

  function checkCurrent(){
    const parts = currentQ.parts;
    let allOK=true;
    parts.forEach((p,i)=>{
      const inp = document.getElementById('ans-'+i);
      const mark = document.getElementById('mark-'+i);
      const fb = document.getElementById('fb-'+i);
      const stu = parseNum(inp && inp.value);
      if(isFinite(stu)) inp.value = to2(stu);
      if(isFinite(stu) && eq2dp(stu, p.val)){
        mark.textContent='✓'; mark.className='marker ok'; fb.textContent='';
      }else{
        mark.textContent='✗'; mark.className='marker no';
        fb.innerHTML = `Ans: <span class="ans">${to2(p.val)} ${unit(p.unit)}</span>`;
        allOK=false;
      }
      inp.disabled=true;
    });
    if(allOK){ score++; correctSoFar++; }
    $scoreTopVal.textContent = `${score} / ${idx+1}`;
    document.getElementById('nextBtn').disabled=false;
    if(mode==='target' && correctSoFar>=target){ finish('Target achieved!'); }
  }

  function nextQ(){
    idx++;
    if(idx % QUESTIONS.length === 0){
      QUESTIONS = buildSet(BATCH);
    }
    renderQ();
    updateTop();
  }

  // Events
  document.getElementById('checkBtn').addEventListener('click', checkCurrent);
  document.getElementById('nextBtn').addEventListener('click', nextQ);
  document.getElementById('newBtn').addEventListener('click', ()=>{
    clearInterval(timerId);
    document.getElementById('startModal').style.display='flex';
  });

  document.addEventListener('keydown', (e)=>{
    if(e.key==='Enter' && !document.getElementById('nextBtn').disabled){ nextQ(); }
    else if(e.key==='Enter' && document.getElementById('nextBtn').disabled){ checkCurrent(); }
  });

  function updateModeFields(){
    const modeEl = document.querySelector('input[name="mode"]:checked');
    const modeVal = modeEl ? modeEl.value : 'timed';
    document.getElementById('timedField').style.display = (modeVal==='timed') ? '' : 'none';
    document.getElementById('targetField').style.display = (modeVal==='target') ? '' : 'none';
  }
  document.querySelectorAll('input[name="mode"]').forEach(r=>r.addEventListener('change', updateModeFields));

  // START button: set globals FIRST, then start worksheet and timer
  document.getElementById('startBtn').addEventListener('click', ()=>{
    nameStr = document.getElementById('nameInput').value.trim() || 'Student';
    const picked = document.querySelector('input[name="mode"]:checked');
    mode = picked ? picked.value : 'timed';

    if(mode==='timed'){
      const sel = parseInt(document.querySelector('input[name="tlimit"]:checked')?.value||'1200',10);
      unlimited = (sel===0);
      timeLeft = unlimited ? 0 : sel;   // <<< correct: set timeLeft here
    }else{
      unlimited = false;
      timeLeft = 0;
      target = clamp(parseInt(document.getElementById('targetInput').value,10)||10,1,1000000);
    }

    document.getElementById('modeTxt').textContent = mode==='timed' ? 'Timed' : 'Target';
    document.getElementById('timeTxt').textContent = (mode==='timed' && !unlimited) ? secsToMMSS(timeLeft) : '—';

    // Start
    document.getElementById('startModal').style.display='none';
    startWorksheet();
  });

  document.getElementById('restartBtn').addEventListener('click', ()=>{
    clearInterval(timerId);
    document.getElementById('startModal').style.display='flex';
  });
  updateModeFields();

  // Fullscreen
  document.getElementById('fsBtn').addEventListener('click', ()=>{
    if(!document.fullscreenElement){ document.documentElement.requestFullscreen?.(); }
    else{ document.exitFullscreen?.(); }
  });
  document.addEventListener('fullscreenchange', ()=>{
    document.getElementById('fsBtn').textContent = document.fullscreenElement ? '✕ Exit full screen' : '⛶ Full screen';
  });

  // Show modal on load
  document.getElementById('startModal').style.display='flex';
});
</script>
</body>
</html>
